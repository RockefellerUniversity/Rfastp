% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/wrappers.R
\name{rfastp}
\alias{rfastp}
\title{R wrap of fastp}
\usage{
rfastp(
  read1 = "",
  read2 = "",
  outputFastq = "",
  unpaired = "",
  failedOut = "",
  merge = FALSE,
  mergeOut = "",
  compressLevel = 4,
  phred64 = FALSE,
  interleaved = FALSE,
  fixMGIid = FALSE,
  adapterTrimming = TRUE,
  adapterSequenceRead1 = "",
  adapterSequenceRead2 = "",
  adapterFasta = "",
  trimFrontRead1 = 0,
  trimTailRead1 = 0,
  trimFrontRead2 = 0,
  trimTailRead2 = 0,
  maxLengthRead1 = 0,
  maxLengthRead2 = 0,
  forceTrimPolyG = FALSE,
  disableTrimPolyG = FALSE,
  minLengthPolyG = 10,
  trimPolyX = FALSE,
  minLengthPolyX = 10,
  cutLowQualFront = FALSE,
  cutLowQualTail = FALSE,
  cutSlideWindowRight = FALSE,
  cutWindowSize = 4,
  cutMeanQual = 20,
  cutFrontWindowSize = 4,
  cutFrontMeanQual = 20,
  cutTailWindowSize = 4,
  cutTailMeanQual = 20,
  cutSlideWindowSize = 4,
  cutSlideWindowQual = 20,
  qualityFiltering = TRUE,
  qualityFilterPhred = 15,
  qualityFilterPercent = 40,
  maxNfilter = 5,
  averageQualFilter = 0,
  lengthFiltering = TRUE,
  minReadLength = 15,
  maxReadLength = 0,
  lowComplexityFiltering = FALSE,
  minComplexity = 30,
  index1Filter = "",
  index2Filter = "",
  maxIndexMismatch = 0,
  correctionOverlap = FALSE,
  minOverlapLength = 30,
  maxOverlapMismatch = 5,
  maxOverlapMismatchPercentage = 20,
  umi = FALSE,
  umiLoc = "",
  umiLength = 0,
  umiPrefix = "",
  umiSkipBaseLength = 0,
  overrepresentationAnalysis = FALSE,
  overrepresentationSampling = 20,
  splitOutput = 0,
  splitByLines = 0,
  splitPrefixPaddingNum = 4,
  reportTitle = "Rfastp Report",
  thread = 2,
  verbose = TRUE
)
}
\arguments{
\item{read1}{read1 input file name [string]}

\item{read2}{read2 input file name [string]}

\item{outputFastq}{string of /path/prefix for output fastq [string]}

\item{unpaired}{for PE input, output file name for reads which the mate
reads failed to pass the QC [string], default NULL, discard it. [string]}

\item{failedOut}{file to store reads that cannot pass the filters default}

\item{merge}{for PE input, A logical(1) indicating whether merge each pair 
of reads into a single read if they are overlaped, unmerged reads will
be write to `output` file. Default is FALSE. the `mergeOut` must be 
set if TRUE.}

\item{mergeOut}{under `merge` mode, file to store the merged reads. [string]}

\item{compressLevel}{compression level for gzip output (1 ~ 9). 1 is fastest, 
9 is smallest, default is 4.}

\item{phred64}{A logical indicating whether the input is using phred64 scoring
(it will be converted to phred33, so the output will still be phred33)}

\item{interleaved}{A logical indicating whether <read1> is an interleaved FASTQ 
which contains both read1 and read2. Default is FALSE.}

\item{fixMGIid}{the MGI FASTQ ID format is not compatible with many BAM 
operation tools, enable this option to fix it. Default is FALSE}

\item{adapterTrimming}{A logical indicating whether run adapter trimming. 
Default is `TRUE`}

\item{adapterSequenceRead1}{the adapter for read1. For SE data, if not 
specified, the adapter will be auto-detected. For PE data, this is used
if R1/R2 are found not overlapped.}

\item{adapterSequenceRead2}{the adapter for read2 (PE data only). This is 
used if R1/R2 are found not overlapped. If not specified, it will be the 
same as <adapterSequenceRead1>}

\item{adapterFasta}{specify a FASTA file to trim both read1 and read2 (if PE) 
by all the sequences in this FASTA file.}

\item{trimFrontRead1}{trimming how many bases in front for read1, default is 0}

\item{trimTailRead1}{trimming how many bases in tail for read1, default is 0'}

\item{trimFrontRead2}{trimming how many bases in front for read2. If it's not 
specified, it will follow read1's settings}

\item{trimTailRead2}{trimming how many bases in tail for read2. If it's not 
specified, it will follow read1's settings}

\item{maxLengthRead1}{if read1 is longer than maxLengthRead1, then trim read1 
at its tail to make it as long as maxLengthRead1 Default 0 means no 
limitation.}

\item{maxLengthRead2}{if read2 is longer than maxLengthRead2, then trim read2 
at its tail to make it as long as maxLengthRead2. Default 0 means no 
limitation. If it's not specified, it will follow read1's settings.}

\item{forceTrimPolyG}{A logical indicating force polyG tail trimming,
trimming is only automatically enabled for Illumina NextSeq/NovaSeq data.}

\item{disableTrimPolyG}{A logical indicating disable polyG tail trimming.}

\item{minLengthPolyG}{the minimum length to detect polyG in the read tail. 
10 by default.}

\item{trimPolyX}{A logical indicating force polyX tail trimming.}

\item{minLengthPolyX}{the minimum length to detect polyX in the read tail. 
10 by default.}

\item{cutLowQualFront}{A logical indiccating move a sliding window from 
front (5') to tail, drop the bases in the window if its mean quality 
< threshold, stop otherwise. Default is `FALSE`}

\item{cutLowQualTail}{A logical indiccating move a sliding window from
tail (3') to front, drop the bases in the window if its mean quality 
< threshold, stop otherwise. Default is `FALSE`}

\item{cutSlideWindowRight}{A logical indicating move a sliding window from
front to tail, if meet one window with mean quality < threshold, drop  
the bases in the window and the right part, and then stop. Default is 
`FALSE`}

\item{cutWindowSize}{the window size option shared by cutLowQualFront,
cutLowQualTail, or cutSlideWindowRight. Range: 1~1000, default: 4}

\item{cutMeanQual}{the mean quality requirement option shared by cutLowQualFront, 
cutLowQualTail or cutSlideWindowRight. Range: 1~36 default: 20}

\item{cutFrontWindowSize}{the window size option of cutLowQualFront, default to 
cutWindowSize if not specified. default: 4}

\item{cutFrontMeanQual}{the mean quality requirement option for cutLowQualFront, 
default to cutMeanQual if not specified. default: 20}

\item{cutTailWindowSize}{the window size option of cutLowQualTail, default to 
cutWindowSize if not specified. default: 4}

\item{cutTailMeanQual}{the mean quality requirement option for cutLowQualTail, 
default to cutMeanQual if not specified. default: 20}

\item{cutSlideWindowSize}{the window size option of cutSlideWindowRight, 
default to cutWindowSize if not specified. default: 4}

\item{cutSlideWindowQual}{the mean quality requirement option for 
cutSlideWindowRight, default to cutMeanQual if not specified. default: 20}

\item{qualityFiltering}{A logical indicating run quality filtering. 
Default is `TRUE`.}

\item{qualityFilterPhred}{the minimum quality value that a base is qualified. 
Default 15 means phred quality >=Q15 is qualified.}

\item{qualityFilterPercent}{Maximum percents of bases are allowed to be 
unqualified (0~100). Default 40 means 40\%}

\item{maxNfilter}{maximum number of N allowed in the sequence. read/pair is 
discarded if failed to pass this filter. Default is 5}

\item{averageQualFilter}{if one read's average quality score < `averageQualFilter`,
then this read/pair is discarded. Default 0 means no requirement.}

\item{lengthFiltering}{A logical indicating whether run lenght filtering. 
Default: TRUE}

\item{minReadLength}{reads shorter than minReadLength will be discarded,
default is 15.}

\item{maxReadLength}{reads longer than maxReadLength will be discarded, 
default 0 means no limitation.}

\item{lowComplexityFiltering}{A logical indicating whethere run low complexity 
filter. The complexity is defined as the percentage of base that is 
different from its next base (base[i] != base[i+1]). Default is `FALSE`}

\item{minComplexity}{the threshold for low complexity filter (0~100). 
Default is 30, which means 30\% complexity is required. (int [=30])}

\item{index1Filter}{specify a file contains a list of barcodes of index1 
to be filtered out, one barcode per line.}

\item{index2Filter}{specify a file contains a list of barcodes of index2 
to be filtered out, one barcode per line.}

\item{maxIndexMismatch}{the allowed difference of index barcode for 
index filtering, default 0 means completely identical.}

\item{correctionOverlap}{A logical indicating run base correction in 
overlapped regions (only for PE data), default is `FALSE`}

\item{minOverlapLength}{the minimum length to detect overlapped region of 
PE reads. This will affect overlap analysis based PE merge, adapter 
trimming and correction. 30 by default.}

\item{maxOverlapMismatch}{the maximum number of mismatched bases to detect
overlapped region of PE reads. This will affect overlap analysis 
based PE merge, adapter trimming and correction. 5 by default.}

\item{maxOverlapMismatchPercentage}{the maximum percentage of mismatched 
bases to detect overlapped region of PE reads. This will affect 
overlap analysis based PE merge, adapter trimming and correction. 
Default 20 means 20\%}

\item{umi}{A logical indicating whethere preprocessing unique molecular
identifier (UMI). Default: `FALSE`}

\item{umiLoc}{specify the location of UMI, can be 
(index1/index2/read1/read2/per_index/per_read)}

\item{umiLength}{length of UMI if the UMI is in read1/read2.}

\item{umiPrefix}{an underline will be used to connect prefix and UMI 
(i.e. prefix=UMI, UMI=AATTCG, final=UMI_AATTCG). No prefix by default}

\item{umiSkipBaseLength}{if the UMI is in read1/read2, skip 
`umiSkipBaseLength` bases following UMI, default is 0.}

\item{overrepresentationAnalysis}{A logical indicating overrepresentation
analysis. Default is `FALSE`}

\item{overrepresentationSampling}{one in `overrepresentationSampling` 
reads will be computed for overrepresentation analysis (1~10000), 
smaller is slower, default is 20.}

\item{splitOutput}{number of files to be splitted (2~999). a sequential number
prefix will be added to output name. Default is 0 (no split)}

\item{splitByLines}{split output by limiting lines of each file(>=1000), a 
sequential number prefix will be added to output name ( 0001.out.fq, 
0002.out.fq...), default is 0 (disabled).}

\item{splitPrefixPaddingNum}{the digits for the sequential number padding (1~10), 
default is 4, so the filename will be padded as 0001.xxx, 0 to disable 
padding}

\item{reportTitle}{Title of the report, default: "Rfastp report"}

\item{thread}{owrker thread number, default is 2}

\item{verbose}{output verbose log information}
}
\value{
returns a json object of the report.
}
\description{
Quality control (Cut adapter, low quality trimming, UMI handling, and etc.) of fastq files.
}
\examples{

require(rjson)

# preprare for the input and output files.
# if the output file exists, it will be OVERWRITEN.

se_read1 <- system.file("extdata","Fox3_Std_small.fq.gz",package="Rfastp")
pe_read1 <- system.file("extdata","reads1.fastq.gz",package="Rfastp")
pe_read2 <- system.file("extdata","reads2.fastq.gz",package="Rfastp")
output_fastq  <- './rfastp_test'


# a normal single-end file

se_json_report <- rfastp(read1 = se_read1, outputFastq = './rfastp_test_se',
         thread = 4)


# merge paired-end data by overlap: 

pe_json_report <- rfastp(read1 = pe_read1, read2 = pe_read2, merge = TRUE, 
         outputFastq = './rfastp_pe_test_unpaired',
         mergeOut = './rfastp_pe_test_merged.fastq.gz')


# a clipr example

clipr_json_report <- rfastp(read1 = se_read1, outputFastq = './rfastp_test_clipr',
         disableTrimPolyG = TRUE,
         cutLowQualFront = TRUE,
         cutFrontWindowSize = 29,
         cutFrontMeanQual = 20,
         cutLowQualTail = TRUE,
         cutTailWindowSize = 1,
         cutTailMeanQual = 5,
         minReadLength = 29,
         adapterSequenceRead1 = 'GTGTCAGTCACTTCCAGCGG'
)
}
\author{
Thomas Carroll, Wei Wang
}
